/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Rust.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(Rust)
package rust;
import java.io.*;




public class Rust/*@bgen(jjtree)*/implements RustTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTRustState jjtree = new JJTRustState();

/*@egen*/

	static SymbolTable symbolTable = new SymbolTable();

  public static void main(String args []) throws ParseException, FileNotFoundException
  {
    /**
     Token token; //Creo el token sobre el que se itera
    
    InputStream input = new FileInputStream("src/rust/prueba.txt");
    SimpleCharStream stream = new SimpleCharStream(input);
    
    RustTokenManager tokenManager = new RustTokenManager(stream); //Creo el manager de los token

	token = tokenManager.getNextToken(); //primer token
	
	while(token.kind != RustConstants.EOF) {
		System.out.println("token: "+token.image +"  "+ tokenImage[token.kind]); //Imprimo la info
		token = tokenManager.getNextToken();
	}
	*/


// Para poder seguir el parser
	InputStream input = new FileInputStream("src/rust/prueba.txt");
    //Rust parser = new Rust(input);
    

    //parser.start();

	new Rust(input);
	try {
		SimpleNode n= Rust.start();
		n.dump("");
		System.out.println("Chorizu y morcilla.");
	  } catch(Exception e) {
		System.out.println("Liadon del 15.");
		System.out.println(e.getMessage());
	  }
    
 }


}

PARSER_END(Rust)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
|<COMMENT_2: ("//"(~["\n"])*) >
}


TOKEN : /* OPERATORS */
{
	  <MULT_DIV: ("*"|"/"|"%") >
	| <ADD_MIN: ("+"|"-") >
	| <RELATIONAL_OP:("<"|">"| ">="|"<="| "=="| "!=")>
	| < ASSIGNMENT: "=" >
	| < RETURN: "->" >
	| < AND: "&&" >
	| < OR: "||">
	| < NEGATIONAL_OP: "!" >
}

TOKEN: //SEPARATORS
{
	<SEMICOLON: ";">
	|<COMA: ",">
	| < DOT:"." >
	| < POINTS: ":" >
	| <OPEN_PAR: "(">
	| <CLOSE_PAR: ")">
	| < OPEN_CURL: "{" >
	| < CLOSE_CURL: "}" >
	| < OPEN_BRACK: "[" >
	| < CLOSE_BRACK: "]" >
	}

TOKEN: //Palabaras reservadas
{
	< FUNCTION : "fn" >
	|< PRINT: ("println!"|"print!") >
	| < IF : "if" >
	| < ELSE: "else" >
	| < LOOP: "loop" >
	| <BREAK: "break" >
	| < WHILE: "while" >
	| < FOR: "for" >
	| < IN: "in" >
	| < STRUCT: "struct" >
	| < RETURN_ST: "return" >
}


TOKEN: //NUMBER
{
  	<INT_NUMBER: (<DIGIT>)+>
	|<REAL_NUMBER: ((<DIGIT>)*(".")(<DIGIT>)+)>
}

TOKEN://POINTERS
{
	< DIRECTION_POINT: "&" >
}



TOKEN: //TIPOS
{
	< LET: "let" >
	| < MUT: "mut" >
	| < #SIGNED: ("i8"|"i16"|"i32"|"i64"|"i128"|"isize") >
	| < #UNSIGNED: ("u8"|"u16"|"u32"|"u64"|"u128"|"usize") >
	| < #FLOAT: ("f32"|"f64") >
	| < #BOOLEAN: "bool" >
	| < #STRING: "String" >
	| < TRUE_FALSE: "true"|"false" >
	| < CONST: "const" >
	| < TYPE: (< SIGNED >|< UNSIGNED >|< FLOAT >|< BOOLEAN >|< STRING >) >
}

TOKEN : //IDENTIFIER
{
  < NAME_CLASS_STRUCTURE : ((["A"-"Z"]) < SEQUENCE_CHAR >)>
 	|<IDENTIFIER: (("'"|<LETTER>)<SEQUENCE_CHAR>)> //Cambie la definicion de identifier
 	//para permitir identificadores como 'counting_up
	| < #DIGIT : ["0"-"9"] >
	| <#LETTER:(["A"-"Z", "a"-"z"])>
	| < #BAR: (	"-"|"_") >
	| < #SEQUENCE_CHAR: (<LETTER>|<DIGIT>|< BAR >)* >
	| < LITERAL_STRING:"\""(~["\""])*"\"" >
	| < CHARACTER:("'"< LETTER >"'") >
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Aqui empezamos el analisis sintactico ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///START OF THE PROGRAM

/**
Comienzo del programa, se lee un programa y se termina con EOF
Its assigned the action of notify that the program is correct
*/
SimpleNode start(): {/*@bgen(jjtree) start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) start */
        try {
/*@egen*/
  	{ System.out.println("Start-> program EOF"); }
	program() <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	  	return jjtn000;
		System.out.println("El programa es correcto.");
		symbolTable.print();
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
A program is composed of functions or composed by structures and functions
*/
void program()         : {/*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Program */
  try {
/*@egen*/
  { System.out.println("program-> structures functions"); }
 structures() functions()
| { System.out.println("program-> functions"); }
		functions()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

///DECLARATION OF STRUCTURES---------------------------------------------------------------------------------------------------------------

/**
There could be one or more structures
*/
void structures()       : { }
{
	{ System.out.println("structures-> struct struct_p"); }
	struct() struct_p() 
}




/**
We use this one to delete the left-recursivity in structures
*/
void struct_p()      : { }
{
  { System.out.println("struct_p-> structures "); }
	structures()
	| { System.out.println("struct_p-> { }"); }
	{ }
}

/**
Declaration of the struct that is outside the body of the function
*/
void struct()        : {/*@bgen(jjtree) Struct */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Struct */
        try {
/*@egen*/
  	{System.out.println("struct - > STRUCT NAME_CLASS_STRUCTURE OPEN_CURL list_declaration_struct CLOSE_CURL");}
< STRUCT > < NAME_CLASS_STRUCTURE >< OPEN_CURL >list_declaration_struct()< CLOSE_CURL >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
 //The name of the struct must start by UPPER CASE, so i defined NAME_CLASS_STRUCTURE
}


/**
 List of the elements of the structure
*/
void list_declaration_struct()      : { }
{
  { System.out.println("list_declaration_struct - > declaration_struct list_declaration_struct"); }
	declaration_struct() list_declaration_struct()
	|{ System.out.println("list_declaration_struct - > { }"); }
	{ }




}
/**
The stmt inside the structure
*/
void declaration_struct()                 : {/*@bgen(jjtree) AttributeStruct */
                                             SimpleNode jjtn000 = new SimpleNode(JJTATTRIBUTESTRUCT);
                                             boolean jjtc000 = true;
                                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) AttributeStruct */
  try {
/*@egen*/
  { System.out.println("declaration_struct - > IDENTIFIER POINTS TYPE COMA"); }
	t= < IDENTIFIER> {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	}
< POINTS > < TYPE >< COMA >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

///DECLARATION OF THE FUNCTIONS-------------------------------------------------------------------------------------------------------------------------


/**
Functions can be one function or more
There are two types of functions, normal functions, and return functions
*/
void functions()       : { }
{
  { System.out.println("functions-> type_function function_p"); }
	type_function() function_p()
}


/**
We use this one to delete the left-recursivity in functions
*/
void function_p()       : { }
{
  { System.out.println("function_p-> functions "); }
	functions()
	| { System.out.println("function_p-> { }"); }
	{ }
}


/**
 The function could be return function or normal function
*/
void type_function()       : { }
{
  LOOKAHEAD(9)
  { System.out.println("type_function-> function"); }
	function()
	|{ System.out.println("type_function-> return_function"); }
	return_function() 
}



/**
The return_function, has a diferent declaration and a diferent body
*/
void return_function()          : {/*@bgen(jjtree) function */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) function */
  try {
/*@egen*/
  { System.out.println("return_function-> return_declaration return_body"); }
	return_declaration() return_body()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


/**
A function is composed by a declaration and a body
*/
void function()           : {/*@bgen(jjtree) procedure */
  SimpleNode jjtn000 = new SimpleNode(JJTPROCEDURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) procedure */
  try {
/*@egen*/
  { System.out.println("function-> declaration body"); }
	declaration() body()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/**
The differenece in the declarations, are in the part after the signature, because, the
return signature has a different end
*/
void return_declaration()      : {}
{
  { System.out.println("return_declaration-> initial_declaration return_signature"); }
	initial_declaration() return_signature()
}


/**
The declaration is composed of the token fn + the signature of the function
*/
void declaration()      : {}
{
  { System.out.println("declaration-> initial_declaration normal_signature"); }
	initial_declaration() normal_signature()
}



/**
This initial declaration is common for the return_function and the normal function
*/
void initial_declaration()      : { }
{
	{ System.out.println("initial_declaration - > FUNCTION signature"); }
	< FUNCTION> signature()
}





/**
the signature starts with IDENTIFIER (the name of the function) a list of parameters between parenthesis and the final
of the signature that can be a return or not.

This part is common for the two types of functions
*/
void signature()            : {/*@bgen(jjtree) signature */
                               SimpleNode jjtn000 = new SimpleNode(JJTSIGNATURE);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; }
{/*@bgen(jjtree) signature */
        try {
/*@egen*/
	{ System.out.println("signature-> IDENTIFIER OPEN_PAR parameters CLOSE_PAR"); } 
	t= < IDENTIFIER> {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	}
	< OPEN_PAR > parameters()< CLOSE_PAR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}


/**
 This part is only for the return fucntions, it means that a function
 returns something
 - > type
*/
void return_signature()                   : {/*@bgen(jjtree) return_value_type */
  SimpleNode jjtn000 = new SimpleNode(JJTRETURN_VALUE_TYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) return_value_type */
  try {
/*@egen*/
  LOOKAHEAD(2)
  { System.out.println("return_signature-> RETURN TYPE"); } 
	< RETURN>< TYPE>
	|{ System.out.println("return_signature-> RETURN OPEN_PAR TYPE CLOSE_PAR"); } 
	< RETURN> < OPEN_PAR >< TYPE>< CLOSE_PAR >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}



/**
THE FINAL SIGNATURE FOR THE OTHER FUNCTIONS COULD BE:
 -> () //It means that there arent nothing returning
 {}
*/
void normal_signature()      : {}
{
	{ System.out.println("normal_signature-> RETURN OPEN_PAR CLOSE_PAR"); } 
	< RETURN> < OPEN_PAR>/*@bgen(jjtree) empty_return_value_type */
                              {
                                SimpleNode jjtn001 = new SimpleNode(JJTEMPTY_RETURN_VALUE_TYPE);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                              }
                              try {
/*@egen*/ < CLOSE_PAR>/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001, true);
                                }
                              }
/*@egen*/                         
	|{ System.out.println("normal_signature-> { }"); } 
	{ } 
}



/**
 parameters of a function, one or more attributes
*/
void parameters()      :{}
{
  { System.out.println("parameters-> attribute attribute_p"); } 
	attribute() attribute_p()
	| { System.out.println("parameters-> { }"); } { } 
}




/**
aatributes separated by a coma
*/
void attribute_p()           : {/*@bgen(jjtree) parameter */
  SimpleNode jjtn000 = new SimpleNode(JJTPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) parameter */
        try {
/*@egen*/
  	{ System.out.println("attribute_p-> COMA parameters attribute_p"); }
	< COMA>parameters() attribute_p()
	| { System.out.println("attribute_p-> { }"); }/*@bgen(jjtree)*/
                                                        {
                                                          jjtree.closeNodeScope(jjtn000, true);
                                                          jjtc000 = false;
                                                        }
/*@egen*/  { }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}




/**
An attribute is like - >  x:i32
*/
void attribute()      : {Token t; }
{
  	{ System.out.println("attribute-> IDENTIFIER POINTS TYPE"); } 
	t= < IDENTIFIER> {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	}
	< POINTS> < TYPE> 
}



/**
The body of the return function is different from the other because IT ALWAYS ENDS WITH A RETURN STMT
*/
void return_body()      : {/*@bgen(jjtree) body */
  SimpleNode jjtn000 = new SimpleNode(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) body */
  try {
/*@egen*/
  LOOKAHEAD(5)
  {System.out.println("body - > OPEN_CURL return_stmt CLOSE_CURL");}
< OPEN_CURL> return_stmt()< CLOSE_CURL> 
|   {System.out.println("body - > OPEN_CURL list_stmt return_stmt CLOSE_CURL");}
< OPEN_CURL> list_stmt()return_stmt()< CLOSE_CURL>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
Block of statements delimeted by curly parenthesis
This is the body for the other functions
FOR EXAMPLE
{
	let x = 12;
}
*/
void body()      : {/*@bgen(jjtree) body */
  SimpleNode jjtn000 = new SimpleNode(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) body */
  try {
/*@egen*/
  {System.out.println("body - > OPEN_CURL list_stmt CLOSE_CURL");}
  < OPEN_CURL> list_stmt()< CLOSE_CURL>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}


 /**
List_stmt could be one ore more stmt
 */
void list_stmt()       :{}
{
  {System.out.println("list_stmt -> stmt stmt_p");}
  stmt()stmt_p()
}





/**
To delete the recursivity in list_stmt
*/
void stmt_p()       :{}
{

	{System.out.println("stmt_p -> list_stmt");}
	list_stmt()
	|{System.out.println("stmt_p -> { }");}
	{ }
}




/**
There could be a lot of stmt:
	assignment_stmt() - > __ = _____
	declaration_stmt() - > type identifier;
	functioncall() - > funcion1()
	print_stmt() - > println!()
	arrays_stmt() - > declaration of arrays or assignment of arrays
	function_call_object() - > identifier.function()
	if_stmt() - > if (){ }else { }
	while_stmt() - > while () { }
	increase_counter () - > i+
	loop_stmt() - > loop;
	for() - > for () { }
	body() _ > To have { } in the middle of the code
	assign_struct_stmt- > To assign a values to a structure
*/
void stmt()       :{}
{
	 LOOKAHEAD(4)
	 {System.out.println("stmt - > assignment_stmt");}
	 assignment_stmt()
	 |LOOKAHEAD(3)
	 { System.out.println("stmt-> arrays_stmt"); }
		arrays_stmt()
	 |LOOKAHEAD(2)
	  {System.out.println("stmt - > declaration_stmt");}
	 	declaration_stmt()
	 |LOOKAHEAD(2)
	 {System.out.println("stmt - > function_call");}
	 	function_call() < SEMICOLON > 
//Pongo aqui el semicolon, porque en alguna operacion se puede usar la llamada auna funcion sin que sea final de linea x = fn()+3;
 	 |{ System.out.println("stmt -> print_stmt");}
	 	print_stmt()
	 |LOOKAHEAD(2)
	 { System.out.println("stmt -> function_call_object");}
		function_call_object() < SEMICOLON > 
	 | { System.out.println("stmt-> if_stmt"); }
		if_stmt()
	 | { System.out.println("stmt-> while_stmt"); }
		while_stmt()
	 |LOOKAHEAD(3){ System.out.println("stmt-> increase_counter_stmt"); }
		increase_counter_stmt()
	 | { System.out.println("stmt-> loop_stmt"); }
		loop_stmt()
	 | { System.out.println("stmt-> for_stmt"); }
		for_stmt()
	 | { System.out.println("stmt-> body"); }
		//Its used when a group of statements appears in the middle of the code delimeted by curly parenth
		body()
	 | { System.out.println("stmt-> assign_structure_stmt"); }
		assign_structure_stmt()
	| { System.out.println("stmt-> expresion"); }
	expresion() < SEMICOLON > 
	
}

////RETURN STMT DECLARATION--------------------------------------------------------------------------------------------------------------------


/**
	The final stmt of a function that returns something
	it could be only an operator without semicolon or
	RETURN operator SEMICOLON
*/
void return_stmt()       : {}
{
{System.out.println("return_stmt_p - > RETURN return_stmt_p SEMICOLON");}
< RETURN_ST > return_stmt_p()< SEMICOLON >
}

/**
The possible values that could be returned
operand
expresion
*/
void return_stmt_p()              : {/*@bgen(jjtree) return_value */
  SimpleNode jjtn000 = new SimpleNode(JJTRETURN_VALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) return_value */
  try {
/*@egen*/
  LOOKAHEAD(2)
  {System.out.println("return_stmt_p - > expresion");}
	expresion()
|LOOKAHEAD(2){System.out.println("return_stmt_p - > operand");}
operand()
|{System.out.println("return_stmt_p - > increase_counter_stmt");}
increase_counter_stmt()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}




///ASSIGNMENT STMT----------------------------------------------------------------------------------------------------------------------------------------

/**
Assignment stmt that could be mutable
let x = 3;
let mut x=3;
x=3;
let x:i32 = 4
let mut x: i32 = 4
*/
void assignment_stmt()                             :{/*@bgen(jjtree) assign_value_to_a_variable */
                                                     SimpleNode jjtn000 = new SimpleNode(JJTASSIGN_VALUE_TO_A_VARIABLE);
                                                     boolean jjtc000 = true;
                                                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; }
{/*@bgen(jjtree) assign_value_to_a_variable */
  try {
/*@egen*/
  {System.out.println("assignment_stmt  -> (declaration)? IDENTIFIER (<POINTS ><TYPE >)? ASSIGNMENT expresion SEMICOLON");}
	(< LET> (< MUT>)? )? t=< IDENTIFIER> {
	  	Position position3 = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry3 = new SymbolTableEntry(token.image, position3);
        symbolTable.addSymbolEntry(entry3);
	}
	(< POINTS> < TYPE> )?< ASSIGNMENT>expresion()< SEMICOLON >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}


///DECLARATION_STMT-----------------------------------------------------------------------------------------------------------------------------

/**
Declaration stmt that could be mutable
let x;
let mut x;
let x: i32;
*/
void declaration_stmt()                   : {/*@bgen(jjtree) declare_variable */
                                              SimpleNode jjtn000 = new SimpleNode(JJTDECLARE_VARIABLE);
                                              boolean jjtc000 = true;
                                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) declare_variable */
  try {
/*@egen*/
  {System.out.println("declaration_stmt  -> LET MUTABLE? IDENTIFIER (<POINTS ><TYPE >)? SEMICOLON");}
< LET > (< MUT > )?
	t= < IDENTIFIER> {
	  	Position position3 = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry3 = new SymbolTableEntry(token.image, position3);
        symbolTable.addSymbolEntry(entry3);
	}
	(< POINTS> < TYPE>)? < SEMICOLON >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

////OPERANDS-------------------------------------------------------------------------------------------------------------------------------

/**
Operands
INT NUMBER
REAL_NUMBER
FUNCTION_CALL_OBJECT ----- identifier.fucntion()
LITERAL_STRING
FUNCTION_CALL
IDENTIFIER
TRUE_FALSE

*/
void operand()      :{Token t;}
{
  {System.out.println("operand -> INT_NUMBER");}/*@bgen(jjtree) Integer */
        {
          SimpleNode jjtn001 = new SimpleNode(JJTINTEGER);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	< INT_NUMBER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/          
  |{System.out.println("operand -> REAL_NUMBER");}/*@bgen(jjtree) Real */
        {
          SimpleNode jjtn002 = new SimpleNode(JJTREAL);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	< REAL_NUMBER >/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/      
  |LOOKAHEAD(2)
  {System.out.println("operand -> function_call_object");}
	function_call_object()
  | {System.out.println("operand -> LITERAL_STRING");}/*@bgen(jjtree) String */
        {
          SimpleNode jjtn003 = new SimpleNode(JJTSTRING);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
	< LITERAL_STRING>/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/        
   | LOOKAHEAD(2)
   {System.out.println("operand -> function_call");}
  function_call()
   | {System.out.println("operand -> IDENTIFIER");}
   t= < IDENTIFIER>/*@bgen(jjtree) Identifier */
                    {
                      SimpleNode jjtn004 = new SimpleNode(JJTIDENTIFIER);
                      boolean jjtc004 = true;
                      jjtree.openNodeScope(jjtn004);
                    }
                    try {
/*@egen*//*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn004, true);
                      jjtc004 = false;
                    }
/*@egen*/ {
	  	Position position4 = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry4 = new SymbolTableEntry(token.image, position4);
        symbolTable.addSymbolEntry(entry4);
	}/*@bgen(jjtree)*/
                    } finally {
                      if (jjtc004) {
                        jjtree.closeNodeScope(jjtn004, true);
                      }
                    }
/*@egen*/            
	|{System.out.println("operand -> TRUE_FALSE");}/*@bgen(jjtree) Boolean */
        {
          SimpleNode jjtn005 = new SimpleNode(JJTBOOLEAN);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
        }
        try {
/*@egen*/
	< TRUE_FALSE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005, true);
          }
        }
/*@egen*/         
}


///FUNCTION_CALL---------------------------------------------------------------------------------------------------------------------------------


/**
function_call - > function(parameters)
*/
void function_call()               :{/*@bgen(jjtree) function_call */
                                     SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION_CALL);
                                     boolean jjtc000 = true;
                                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) function_call */
  try {
/*@egen*/
  {System.out.println("function_call -> IDENTIFIER OPEN_PAR a_parameters CLOSE_PAR");}
	t= < IDENTIFIER> {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	}
	< OPEN_PAR > a_parameters()< CLOSE_PAR>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}




/**
Parameters of a function call
*/
void a_parameters()      :{}
{
  {System.out.println("a_parameters -> operand a_parameters_p");}
	operand()a_parameters_p()
	|{System.out.println("a_parameters -> { }");}
	 { }
}




/**
To delete the recursivity in a_parameters
*/
void a_parameters_p()      :{}
{
  {System.out.println("a_parameters_p -> COMA a_parameters");}
	< COMA > a_parameters()
	|{System.out.println("a_parameters_p -> { }");}
	{ }
}


// PRINT_STMT-----------------------------------------------------------------------------------------------------------------------------------------------------

/**
print_stmt :
println!("This is an example")
println!(" { }", 3)
*/
void print_stmt()        :{/*@bgen(jjtree) print */
  SimpleNode jjtn000 = new SimpleNode(JJTPRINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) print */
  try {
/*@egen*/
  {System.out.println("print_stmt -> PRINT OPEN PAR LITERAL_STRING (COMA operand)? CLOSE_PAR SEMICOLON ");}
< PRINT >< OPEN_PAR > a_parameters()< CLOSE_PAR > < SEMICOLON >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}


////EXPRESIONS----------------------------------------------------------------------------------------------------------------------------------------


/**
Expresion of type x+3+4...
*/
void expresion()               :{/*@bgen(jjtree) #Add_Min(> 1) */
  SimpleNode jjtn000 = new SimpleNode(JJTADD_MIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Add_Min(> 1) */
  try {
/*@egen*/
  {System.out.println("expresion - > mult_div_expresion expresion_p");}
	multi_div_expresion() expresion_p()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/ 
}




/**
 operand with another mult_div expr_p
*/
void multi_div_expresion()                :{/*@bgen(jjtree) #Mult_Div(> 1) */
  SimpleNode jjtn000 = new SimpleNode(JJTMULT_DIV);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Mult_Div(> 1) */
  try {
/*@egen*/
  {System.out.println("multi_div_expresion - > operand multi_div_expr_p");}
	operand() multi_div_expr_p()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}





/**
	To create the operations
*/
void multi_div_expr_p()       :{}
{
  {System.out.println("multi_div_expr_p - > MULT_DIV operand multi_div_expr_p");}
	< MULT_DIV > operand() multi_div_expr_p()
	|{System.out.println("multi_div_expr_p - > { }");}
	 { }
}





/**
	To create the operations
*/
void expresion_p()       :{Token t;}
{
  {System.out.println("expresion_p - > ADD_MIN operand expresion_p");}
	< ADD_MIN > multi_div_expresion() expresion_p()  
	|{System.out.println("expresion_p -> { }");}
	{ }
}



///FUNCTION_CALL_OBJECT-----------------------------------------------------------------------------------------------------------------------------------------


/**
Call from an object.
spaces.len()
spaces.trim().size()
*/
void function_call_object()                      :{/*@bgen(jjtree) function_call_object */
                                                   SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION_CALL_OBJECT);
                                                   boolean jjtc000 = true;
                                                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; }
{/*@bgen(jjtree) function_call_object */
  try {
/*@egen*/
  {System.out.println("function_call_object - > IDENTIFIER (DOT FUNCTION_CALL)+");}
	t= < IDENTIFIER> {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	}
	(< DOT > function_call())+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ //There could be more than one function call spaces.trim().len()
}




///IF_STMT-------------------------------------------------------------------------------------------------------------------------------------



/**
	Create a conditional sentence
*/
void if_stmt()     :{/*@bgen(jjtree) If */
  SimpleNode jjtn000 = new SimpleNode(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) If */
        try {
/*@egen*/
  	{ System.out.println("if_stmt-> IF condition body_if"); }
< IF > condition() body_if()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}




/**
	There could be diferent ends for the if
	ELSE
	ELSE IF...
	NOTHING
*/
void final_if()      :{}
{
  LOOKAHEAD(2)
  { System.out.println("final_if-> ELSE IF condition body_if"); }
	< ELSE >/*@bgen(jjtree) else_if */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTELSE_IF);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/< IF >/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/          condition() body_if() 
	| { System.out.println("final_if->ELSE body "); }
	< ELSE >/*@bgen(jjtree) else_ */
                {
                  SimpleNode jjtn002 = new SimpleNode(JJTELSE_);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/body()/*@bgen(jjtree)*/
                } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    throw (RuntimeException)jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                    throw (ParseException)jjte002;
                  }
                  throw (Error)jjte002;
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                  }
                }
/*@egen*/       
|  { System.out.println("final_if-> { }"); }
	{}
}


/**
Body of the if
*/
void body_if()      : { }
{
  { System.out.println("body_if-> body final_if"); }
	body() final_if()
}



/**
The condition could be a comparaison or a boolean expresion
*/
void condition()           :{/*@bgen(jjtree) condition */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) condition */
  try {
/*@egen*/
  LOOKAHEAD(2)
  	{ System.out.println("condition-> comparison"); }
		comparison()
	| { System.out.println("condition-> boolean_expr"); }
		boolean_expr()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



/**
Comparaison x > 3
*/
void comparison()              :{/*@bgen(jjtree) comparaison */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPARAISON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) comparaison */
        try {
/*@egen*/
  	{ System.out.println("comparison-> expresion RELATIONAL_OP expresion"); }
	expresion()< RELATIONAL_OP >expresion()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
Boolean expresion
*/
void boolean_expr()               :{/*@bgen(jjtree) #Or_expr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(JJTOR_EXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Or_expr(> 1) */
        try {
/*@egen*/
  	{ System.out.println("boolean_expr-> and_expr boolean_expr_p"); }
	and_expr() boolean_expr_p()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}



/**
To delete recursivity on boolean_expr
*/
void boolean_expr_p()       :{}
{
  	{ System.out.println("boolean_expr_p-> OR and_expr boolean_expr_p"); }
	< OR > and_expr() boolean_expr_p()
	| { System.out.println("boolean_expr_p-> { }"); } { }
}



/**
And_expr
*/
void and_expr()               :{/*@bgen(jjtree) #And_expr(> 1) */
  SimpleNode jjtn000 = new SimpleNode(JJTAND_EXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #And_expr(> 1) */
        try {
/*@egen*/
  	{ System.out.println("and_expr-> boolean_operand and_expr_p"); }
	boolean_operand() and_expr_p()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}



/**
To delete recursivity on and_expr
*/
void and_expr_p()       :{}
{
  LOOKAHEAD(2){ System.out.println("and_expr_p-> AND boolean_operand and_expr_p"); }
	< AND >boolean_operand() and_expr_p()
	| { System.out.println("and_expr_p-> AND OPEN_PAR boolean_operand CLOSE_PAR and_expr_p"); }
		< AND ><OPEN_PAR >boolean_operand()< CLOSE_PAR > and_expr_p()
  	| { System.out.println("and_expr_p-> { }"); }
  		{ }
}



/**
	Operands of a boolean expresion
	Comparaison
	!operand
	operand
*/
void boolean_operand()      :{}
{
  LOOKAHEAD(2)
  	{ System.out.println("boolean_operand-> comparison"); }
	comparison() 

	| { System.out.println("boolean_operand-> NEGATIONAL_OP operand"); }
	< NEGATIONAL_OP >/*@bgen(jjtree) negational_boolean */
                         {
                           SimpleNode jjtn001 = new SimpleNode(JJTNEGATIONAL_BOOLEAN);
                           boolean jjtc001 = true;
                           jjtree.openNodeScope(jjtn001);
                         }
                         try {
/*@egen*/operand()/*@bgen(jjtree)*/
                         } catch (Throwable jjte001) {
                           if (jjtc001) {
                             jjtree.clearNodeScope(jjtn001);
                             jjtc001 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte001 instanceof RuntimeException) {
                             throw (RuntimeException)jjte001;
                           }
                           if (jjte001 instanceof ParseException) {
                             throw (ParseException)jjte001;
                           }
                           throw (Error)jjte001;
                         } finally {
                           if (jjtc001) {
                             jjtree.closeNodeScope(jjtn001, true);
                           }
                         }
/*@egen*/                    

	| { System.out.println("boolean_operand-> operand"); }
	 operand()
|{ System.out.println("boolean_operand-> OPEN_PAR boolean_expr CLOSE_PAR"); }
< OPEN_PAR > boolean_expr() < CLOSE_PAR >
}


////WHILE_STMT---------------------------------------------------------------------------------------------------------------------------------

/**
loop While
while
condition
body
*/
void while_stmt()        :{/*@bgen(jjtree) While */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) While */
  try {
/*@egen*/
  { System.out.println("while_stmt-> WHILE condition body_while"); }
	< WHILE > condition() body()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
To increase a counter, is also used in the loops
*/
void increase_counter_stmt()                  : {/*@bgen(jjtree) IncreaseCounter */
                                                 SimpleNode jjtn000 = new SimpleNode(JJTINCREASECOUNTER);
                                                 boolean jjtc000 = true;
                                                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; }
{/*@bgen(jjtree) IncreaseCounter */
        try {
/*@egen*/
	{ System.out.println("increase_counter_stmt-> IDENTIFIER ADD ASSIGNMENT expresion SEMICOLON"); }
	t= < IDENTIFIER> {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	} < ADD_MIN > < ASSIGNMENT > expresion()< SEMICOLON >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}



////LOOP_STMT-------------------------------------------------------------------------------------------------------------------


/**
loop body
*/
void loop_stmt()      : {/*@bgen(jjtree) loop */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) loop */
        try {
/*@egen*/
	{ System.out.println("loop_stmt-> LOOP body"); }
	< LOOP > body()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



//// FOR_STMT-----------------------------------------------------------------------------------------------

/**
For stmt that defines the loop for.
*/
void for_stmt()     : {/*@bgen(jjtree) For */
                        SimpleNode jjtn000 = new SimpleNode(JJTFOR);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) For */
  try {
/*@egen*/
  { System.out.println("for_stmt - > FOR IDENTIFIER IN IDENTIFIER body"); }
	< FOR > t= < IDENTIFIER> {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	}< IN > < IDENTIFIER> body()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



////ASSIGNATION OF VALUES TO STRUCTURES-------------------------------------------------------------------------------------------------------


/**
Code inside the function to assign a value to the declarations of a structure

User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
*/
void assign_structure_stmt()               : {/*@bgen(jjtree) assign_struct */
                                              SimpleNode jjtn000 = new SimpleNode(JJTASSIGN_STRUCT);
                                              boolean jjtc000 = true;
                                              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) assign_struct */
  try {
/*@egen*/
  { System.out.println("assign_structure_stmt - > NAME_CLASS_STRUCTURE OPEN_CURL list_operands CLOSE_CURL"); }
	t= < NAME_CLASS_STRUCTURE > {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	}< OPEN_CURL >list_operands()< CLOSE_CURL >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}


/**
List of the operands of the assignment of the structure
*/
void list_operands()      : {}
{
  { System.out.println("list_operands - > operand_assign_structure COMA list_operands"); }
	operand_assign_structure()
	< COMA > list_operands() 

	|{ System.out.println("list_operands - > { }"); }
	 { }
}





/**
There could be two types
        email,
        sign_in_count: 1,
    }
*/
void operand_assign_structure()      : {Token t; }
{
  LOOKAHEAD(2)
  { System.out.println("operand_assign_structure - > IDENTIFIER POINTS operand"); }
	t= < IDENTIFIER> {
	  	Position position = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry = new SymbolTableEntry(token.image, position);
        symbolTable.addSymbolEntry(entry);
	}< POINTS > operand()

	|{ System.out.println("operand_assign_structure - >operand"); }
	operand() 
}


////ARRAY----------------------------------------------------------------------------------------------------------

/**
	Create a array the structure is: let IDENTIFIER: [Type; length] asignation
*/
void arrays_stmt()       : {/*@bgen(jjtree) Array */
  SimpleNode jjtn000 = new SimpleNode(JJTARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Array */
  try {
/*@egen*/
  {System.out.println("array_stmt - > declaration_array final_array SEMICOLON");}
	declaration_array() final_array() < SEMICOLON >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}


/**
FINAL of the array
In this way, an array stmt could be
declaration+ assignment
Only declaration
*/
void final_array()      : { }
{
  {System.out.println("final_array - > assignment_array");}
  assignment_array()
|  {System.out.println("final_array - > { }");}
 { }
}


/**
Declaration of the array
*/
void declaration_array()                   : {/*@bgen(jjtree) Declaration_Array */
                                              SimpleNode jjtn000 = new SimpleNode(JJTDECLARATION_ARRAY);
                                              boolean jjtc000 = true;
                                              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; }
{/*@bgen(jjtree) Declaration_Array */
    try {
/*@egen*/
    {System.out.println("declaration_array - > LET IDENTIFIER POINTS OPEN_BRACK TYPE SEMICOLON INT_NUMBER CLOSE_BRACK");}
	< LET>
	t= < IDENTIFIER> {
	  	Position position2 = new Position(token.beginLine, token.beginColumn, token.endLine, token.endColumn);
        SymbolTableEntry entry2 = new SymbolTableEntry(token.image, position2);
        symbolTable.addSymbolEntry(entry2);
	} < POINTS> < OPEN_BRACK>< TYPE> < SEMICOLON > < INT_NUMBER >< CLOSE_BRACK >/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
	Create the assignment in the array
*/
void assignment_array()                      : {/*@bgen(jjtree) Initialization_array */
  SimpleNode jjtn000 = new SimpleNode(JJTINITIALIZATION_ARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Initialization_array */
        try {
/*@egen*/
	{ System.out.println("assignment_array- > ASSIGNMENT OPEN_BRACK body_assignment_array CLOSE_BRACK"); }
	< ASSIGNMENT > <OPEN_BRACK > body_assignment_array() < CLOSE_BRACK >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
	Create the body of the assignment array: = [1,pita,morcilles,gatu,8]
*/
void body_assignment_array()     : {}
{
	{ System.out.println("body_assignment_array- > operand COMA?"); }
	 operand()(< COMA >)?body_assignment_array()

	| { System.out.println("body_assignment_array- > { }"); } { }
}


